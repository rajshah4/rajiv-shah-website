<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Interactive visualization of extremely wide one-hot encoding transformation showing the curse of dimensionality in machine learning preprocessing">
    <meta name="keywords" content="one-hot encoding, curse of dimensionality, sparse matrix, machine learning, data transformation, categorical variables, data preprocessing, sparsity">
    <title>Extremely Wide One-Hot Encoding - The Curse of Dimensionality</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX support -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Add any custom CSS here */
        .widget-container {
            margin: 2rem auto;
            padding: 1rem;
            border-radius: 0.5rem;
            background-color: #111827;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        /* Responsive container */
        .content-wrapper {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        /* Documentation styling */
        .docs-section {
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        h1 {
            font-size: 2.25rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #1f2937;
        }
        
        h2 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-top: 2rem;
            margin-bottom: 0.75rem;
            color: #1f2937;
        }
        
        p {
            margin-bottom: 1rem;
        }
        
        code {
            background-color: #f3f4f6;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-family: monospace;
        }
        
        pre {
            background-color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin-bottom: 1.5rem;
        }
        
        @keyframes pulseColumn {
          from { opacity: 0.5; }
          to { opacity: 0.9; }
        }
    </style>
</head>
<body class="bg-white text-gray-800">
    <div class="content-wrapper">
        <!-- Documentation Section -->
        <div class="docs-section">
            <h1>Extremely Wide One-Hot Encoding: The Curse of Dimensionality</h1>
            
            <p>
                This visualization dramatically demonstrates the "curse of dimensionality" — a critical problem 
                that occurs when one-hot encoding categorical variables with many unique values. Watch as a simple 
                dataset with just 4 columns expands to over 150 columns, creating an extremely sparse matrix.
            </p>
            
            <h2>The Curse of Dimensionality Problem</h2>
            <p>
                One-hot encoding is a standard technique for handling categorical variables in machine learning.
                However, when a categorical feature has many possible values (like product categories, ZIP codes, 
                or user IDs), one-hot encoding creates an explosion in dimensionality:
            </p>
            <ul class="list-disc ml-6 mb-4">
                <li class="mb-2">A single categorical column with 100 unique values becomes 100 binary columns</li>
                <li class="mb-2">This makes your dataset extremely <em>wide</em> and <em>sparse</em> (mostly zeros)</li>
                <li class="mb-2">Models often perform poorly on extremely sparse data</li>
                <li class="mb-2">Computational complexity increases dramatically</li>
                <li class="mb-2">Increased risk of overfitting</li>
            </ul>
            
            <h2>How This Visualization Works</h2>
            <p>
                The animation shows a progression through increasingly extreme one-hot encoding:
            </p>
            <ol class="list-decimal ml-6 mb-4">
                <li class="mb-2">Starting with a simple 4-column dataset (id, customer, category, purchase)</li>
                <li class="mb-2">Moving through stages of encoding with more and more categorical columns</li>
                <li class="mb-2">Ending with 150+ columns, most containing only zeros (an extremely sparse matrix)</li>
            </ol>
            <p>
                Watch how the dataset width grows dramatically while becoming increasingly sparse. This visually 
                demonstrates why handling high-cardinality categorical features often requires techniques beyond 
                simple one-hot encoding.
            </p>
        </div>
        
        <!-- Widget Container -->
        <div class="widget-container" id="widget-root"></div>
        
        <!-- Additional Information -->
        <div class="docs-section">
            <h2>Alternatives to One-Hot Encoding for High-Cardinality Features</h2>
            <p>
                When dealing with categorical features that have many unique values, consider these alternatives:
            </p>
            <ul class="list-disc ml-6 mb-4">
                <li class="mb-2"><strong>Feature Hashing:</strong> Maps categories to a fixed number of dimensions using a hash function</li>
                <li class="mb-2"><strong>Target Encoding:</strong> Replaces categories with their target mean values</li>
                <li class="mb-2"><strong>Embeddings:</strong> Learns dense vector representations of categories (common in deep learning)</li>
                <li class="mb-2"><strong>Dimensionality Reduction:</strong> Apply PCA or t-SNE after one-hot encoding</li>
                <li class="mb-2"><strong>Binary Encoding:</strong> Encodes the unique values as binary code, then creates columns for each digit</li>
            </ul>
            <p>
                These techniques can significantly reduce dimensionality while preserving most of the information 
                in high-cardinality categorical features.
            </p>
        </div>
        <footer class="mt-12 border-t border-gray-200 pt-6 pb-8 text-center text-gray-600">
          <p>This interactive visualization is part of 
            <a href="https://projects.rajivshah.com/blog" class="text-blue-600 hover:text-blue-800 underline">
              projects.rajivshah.com/blog
            </a>
          </p>
          <p class="text-sm mt-2">© Rajiv Shah @rajistics</p>
        </footer>
    </div>

    <!-- Your React Component Script -->
    <script type="text/babel">
        // Import React hooks
        const { useState, useEffect } = React;
        
        // Extremely Wide One-Hot Encoding Component
        const ExtremelyWideOneHotEncoding = () => {
          const [animationStage, setAnimationStage] = useState(0);
          const [showExpansion, setShowExpansion] = useState(false);
          
          // Create a massive list of categorical values for extreme width
          const generateCategories = () => {
            // Product categories (100+ categories)
            const baseCategories = [
              "Electronics", "Clothing", "Home", "Beauty", "Books", "Toys", "Sports", 
              "Automotive", "Garden", "Jewelry", "Office", "Pet", "Food", "Health", 
              "Baby", "Tools", "Music", "Movies", "Art", "Craft", "Kitchen", "Furniture",
              "Appliances", "Shoes", "Luggage", "Watches", "Eyewear", "Decor", "Outdoors", "Gaming"
            ];
            
            // Expand each base category with subcategories
            const expandedCategories = [];
            baseCategories.forEach(cat => {
              expandedCategories.push(cat);
              for (let i = 1; i <= 3; i++) {
                expandedCategories.push(`${cat}_Type${i}`);
              }
            });
            
            // Add country variants for each base category
            const countries = ["US", "UK", "EU", "Asia"];
            baseCategories.forEach(cat => {
              countries.forEach(country => {
                expandedCategories.push(`${cat}_${country}`);
              });
            });
            
            return expandedCategories;
          };
          
          const allCategories = generateCategories();
          
          // Original dataset with categorical variable
          const originalData = Array(6).fill().map((_, i) => {
            // Assign one of the base categories randomly
            const categoryIndex = Math.floor(Math.random() * 30);
            return { 
              id: i + 1,
              customer: `Customer_${i + 1}`,
              category: allCategories[categoryIndex],
              purchase: Math.round(Math.random() * 100 + 50)
            };
          });
          
          // Get visible categories based on animation stage
          const getVisibleCategories = () => {
            if (animationStage === 0) {
              return [];
            } else if (animationStage === 1) {
              return allCategories.slice(0, 10); // First few columns
            } else if (animationStage === 2) {
              return allCategories.slice(0, 30); // More columns
            } else if (animationStage === 3) {
              return allCategories.slice(0, 80); // Many columns
            } else {
              return allCategories; // All columns (150+)
            }
          };
          
          const visibleCategories = getVisibleCategories();
          
          // Generate one-hot encoded data
          const encodedData = originalData.map(row => {
            const encodedRow = { ...row };
            
            // Add one-hot encoded columns
            visibleCategories.forEach(category => {
              const columnName = `cat_${category.toLowerCase().replace(/[\s_]+/g, '_')}`;
              encodedRow[columnName] = row.category === category ? 1 : 0;
            });
            
            // Remove the original category column in final stages
            if (animationStage >= 3) {
              delete encodedRow.category;
            }
            
            return encodedRow;
          });
          
          // Get column headers
          const getColumnHeaders = () => {
            const baseColumns = ['id', 'customer', 'category', 'purchase'];
            
            if (animationStage === 0) {
              return baseColumns;
            } else {
              const oneHotColumns = visibleCategories.map(cat => 
                `cat_${cat.toLowerCase().replace(/[\s_]+/g, '_')}`
              );
              
              if (animationStage >= 3) {
                return ['id', 'customer', 'purchase', ...oneHotColumns];
              } else {
                return [...baseColumns, ...oneHotColumns];
              }
            }
          };
          
          const columnHeaders = getColumnHeaders();
          
          // Visual metrics
          const getMetrics = () => {
            return {
              originalWidth: 4,
              currentWidth: columnHeaders.length,
              expansionFactor: Math.round((columnHeaders.length / 4) * 10) / 10,
              oneHotCount: columnHeaders.length - (animationStage >= 3 ? 3 : 4)
            };
          };
          
          const metrics = getMetrics();
          
          useEffect(() => {
            // Start animation
            setShowExpansion(true);
            
            // Progress through animation stages
            const timer = setTimeout(() => {
              if (animationStage < 5) {
                setAnimationStage(prev => prev + 1);
              } else {
                // Reset animation after reaching the end
                setTimeout(() => {
                  setShowExpansion(false);
                  setTimeout(() => {
                    setAnimationStage(0);
                    setShowExpansion(true);
                  }, 1500);
                }, 4000);
              }
            }, 2500);
            
            return () => clearTimeout(timer);
          }, [animationStage]);
          
          return (
            <div className="flex flex-col items-center justify-center w-full bg-gray-900 text-white p-4 overflow-hidden">
              <div className="mb-6 text-center">
                <h2 className="text-3xl font-bold">One-Hot Encoding: Extreme Width Visualization</h2>
                <div className="text-xl mt-2">
                  {animationStage === 0 && "Original dataset: 4 columns"}
                  {animationStage === 1 && "Initial encoding: 14 columns"}
                  {animationStage === 2 && "Growing wider: 34 columns"}
                  {animationStage === 3 && "Extreme width: 83 columns"}
                  {animationStage === 4 && "Maximum expansion: 153+ columns!"}
                  {animationStage === 5 && `Original: 4 columns → Now: ${metrics.currentWidth} columns (${metrics.expansionFactor}× wider!)`}
                </div>
              </div>
              
              <div className="w-full bg-gradient-to-r from-blue-700 to-blue-900 p-2 rounded-t-lg">
                <div className="flex justify-between items-center">
                  <div className="text-lg font-bold">Dataset Structure</div>
                  <div className="text-xl font-mono">{metrics.currentWidth} columns total</div>
                </div>
              </div>
              
              <div className="relative w-full overflow-hidden bg-gray-800 rounded-b-lg mb-4">
                <div 
                  className="transition-all duration-1000 ease-in-out"
                  style={{ 
                    width: showExpansion ? (animationStage === 0 ? '100%' : '8000px') : '100%',
                    overflow: 'hidden',
                    height: '350px',
                    position: 'relative'
                  }}
                >
                  {/* Visual representation of columns rather than actual table */}
                  <div className="flex h-full">
                    {/* Base columns */}
                    {(animationStage >= 3 ? ['id', 'customer', 'purchase'] : ['id', 'customer', 'category', 'purchase']).map(col => (
                      <div key={col} className="flex-shrink-0 w-24 h-full border-r border-gray-600 bg-blue-600 p-2">
                        <div className="text-sm font-mono text-center">{col}</div>
                        <div className="h-full flex flex-col justify-around p-1">
                          {originalData.map((_, idx) => (
                            <div key={idx} className="bg-blue-300 bg-opacity-30 h-8 rounded my-1"></div>
                          ))}
                        </div>
                      </div>
                    ))}
                    
                    {/* One-hot encoded columns */}
                    {visibleCategories.map((cat, idx) => (
                      <div 
                        key={cat}
                        className="flex-shrink-0 w-16 h-full border-r border-gray-700 bg-green-800 p-1"
                        style={{
                          opacity: 1 - (idx / (allCategories.length * 1.5)),
                          animation: `pulseColumn ${0.5 + Math.random() * 2}s infinite alternate`
                        }}
                      >
                        <div className="text-xs font-mono text-center truncate">{cat.split('_')[0]}</div>
                        <div className="h-full flex flex-col justify-around py-1">
                          {originalData.map((row, rowIdx) => {
                            const isOne = row.category === cat;
                            return (
                              <div 
                                key={rowIdx} 
                                className={`h-8 rounded my-1 flex items-center justify-center font-mono text-xs
                                  ${isOne ? 'bg-green-500' : 'bg-gray-700'}`}
                              >
                                {isOne ? '1' : '0'}
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    ))}
                    
                    {/* Add misty fade at the end */}
                    <div className="absolute right-0 top-0 h-full w-64 bg-gradient-to-l from-gray-900 to-transparent z-10"></div>
                  </div>
                </div>
              </div>
              
              <div className="w-full mt-4">
                <div className="text-xl font-bold text-center mb-2">Dataset Expansion Visualization</div>
                <div className="relative h-16 bg-gray-800 rounded-lg p-2">
                  {/* Visual expansion bar */}
                  <div className="relative w-full h-full">
                    {/* Original dataset */}
                    <div className="absolute left-0 h-full w-16 bg-blue-600 rounded-l-md flex items-center justify-center">
                      <span className="text-white font-mono text-xs">4 cols</span>
                    </div>
                    
                    {/* Animated expansion */}
                    <div 
                      className="absolute left-16 h-full bg-gradient-to-r from-green-800 to-green-600 transition-all duration-1000 rounded-r-md overflow-hidden flex items-center"
                      style={{
                        width: showExpansion ? 
                          (animationStage === 0 ? '0' : 
                           animationStage === 1 ? '100px' : 
                           animationStage === 2 ? '300px' : 
                           animationStage === 3 ? '600px' : '1000px') : '0'
                      }}
                    >
                      <div 
                        className="absolute right-4 text-white font-mono text-sm flex items-center"
                        style={{ opacity: animationStage > 0 ? 1 : 0 }}
                      >
                        <span>+{metrics.oneHotCount} one-hot columns</span>
                      </div>
                      
                      {/* Visual representation of sparsity */}
                      {Array(50).fill().map((_, i) => (
                        <div 
                          key={i} 
                          className="absolute bg-white rounded-full"
                          style={{
                            width: '4px',
                            height: '4px',
                            left: `${Math.random() * 100}%`,
                            top: `${Math.random() * 100}%`,
                            opacity: 0.6
                          }}
                        ></div>
                      ))}
                    </div>
                  </div>
                </div>
                
                <div className="text-center mt-4 text-lg">
                  <span className="font-bold text-2xl text-green-400">{metrics.expansionFactor}×</span> wider than the original dataset!
                </div>
                
                <div className="text-center mt-2 text-sm text-gray-400">
                  With {allCategories.length} categories, the dataset is now extremely sparse —
                  each row contains just 1 non-zero value across {allCategories.length} encoded columns
                </div>
              </div>
            </div>
          );
        };
        
        // Render the component
        const rootElement = document.getElementById('widget-root');
        const root = ReactDOM.createRoot(rootElement);
        root.render(<ExtremelyWideOneHotEncoding />);
    </script>
</body>
</html>